################################
# kvm有効化
#   -enable-kvm
#   エミュレーションでなくネイティブ実行する
#   使用できる環境では有効化すべき
qemu-system-x86_64 -kernel path/to/bzImage -initrd path/to/rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init nokaslr" -nographic -enable-kvm

# Intel VT-x または AMD-V があること
grep -E '(vmx|svm)' /proc/cpuinfo

# ホストでkvmモジュールをロード済みであること
lsmod | grep kvm

ls -l /dev/kvm
# crw-rw----+ 1 root kvm 10, 232 Feb  7 12:34 /dev/kvm
# 権限がなければ
sudo chmod 666 /dev/kvm


################################
# ターミナルサイズとqemuゲストのコンソールサイズを合わせるには
# ゲストでxtermパッケージの resizeコマンドで


################################
# GDBでカーネルをステップ実行

# 事前にゲストkernelをデバッグ情報付きビルドする (以下 kernel v5.x 例)
# cd linux
# make defconfig
# make menuconfig
#   Kernel hacking -> [*] Kernel debugging
#   Kernel hacking -> Compile-time checks and compiler options -> [*] Compile the kernel with debug info
#   Kernel hacking -> printk and dmesg options -> [*] Enable dynamic printk() support
#   Kernel hacking -> Tracers -> [*] Kernel Function Tracer
#                                [*] Kernel Function Graph Tracer
#   Processor type and features -> [ ] EFI runtime service support
#                                  [ ] Build a relocatable kernel
# time make -j $(nproc)

qemu-system-x86_64 -kernel path/to/bzImage -initrd path/to/rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init nokaslr" -nographic -gdb tcp::12345 -S

# gdb 例
# (gdb) target remote localhost:12345
# (gdb) symbol-file path/to/linux/vmlinux
# (gdb) directory path/to/linux
# (gdb) b start_kernel
# (gdb) layout split
# (gdb) c


################################
# edu pciデバイスを追加
#   -device edu
qemu-system-x86_64 -kernel path/to/bzImage -initrd path/to/rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init nokaslr" -nographic -device edu

# pciドライバ実験など


################################
# IRQドメインと割り込み記述子のデバッグメッセージを有効化
#   irqdomain.c +p irqdomain.c内のpr_debug()を全て有効化
#   irqdesc.c +p   irqdesc.c内のpr_debug()を全て有効化
qemu-system-x86_64 -kernel path/to/bzImage -initrd path/to/rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init nokaslr dyndbg=\"file irqdomain.c +p; file irqdesc.c +p\"" -nographic -device edu

# 事前にゲストkernelをdynamic printk を有効化する必要ある


################################
# pci_assign_irq()関数の呼び出しツリーをトレース
#   ftrace=function_graph              関数の呼び出し階層を記録
#   ftrace_graph_filter=pci_assign_irq この関数だけに絞る
#   tp_printk                          tracepointをカーネルログに出力
#   trace_buf_size=1M                  トレースバッファを1MBに拡大
qemu-system-x86_64 -kernel path/to/bzImage -initrd path/to/rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init nokaslr tp_printk trace_buf_size=1M ftrace=function_graph ftrace_graph_filter=pci_assign_irq" -nographic -device edu

#   ftrace_graph_filter=pin_2_irq この関数だけに絞る
qemu-system-x86_64 -kernel path/to/bzImage -initrd path/to/rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init nokaslr tp_printk trace_buf_size=1M ftrace=function_graph ftrace_graph_filter=pin_2_irq" -nographic -device edu

# 事前にゲストkernelをfunction tracer を有効化する必要ある


################################
# APIC詳細ログ
#   apic=verbose  Local APICとI/O APICの詳細ログ
#   debug         カーネル全体のデバッグメッセージ増加
#   -smp 2        2コアCPU（マルチコアでの割り込み分散を確認？）
qemu-system-x86_64 -kernel path/to/bzImage -initrd path/to/rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init nokaslr apic=verbose debug" -nographic -device edu -smp 2


################################
# ホストとゲスト間でファイル共有

# 事前にゲストkernelのビルドでP9を有効にする ここを参照
# https://wiki.qemu.org/Documentation/9psetup
# ->
# CONFIG_NET_9P=y
# CONFIG_NET_9P_VIRTIO=y
# CONFIG_9P_FS=y
# CONFIG_9P_FS_POSIX_ACL=y
# CONFIG_VIRTIO=y
# CONFIG_VIRTIO_PCI=y

# -virtfs
#   local                      ホストのローカルファイルシステムを共有
#   path=/tmp/shared           ホスト側の共有ディレクトリ
#   mount_tag=shared           ゲスト側でマウントする際のタグ名
#   security_model=passthrough ホストの権限をそのまま使う
#   id=shared                  この共有の識別子
qemu-system-x86_64 -kernel path/to/bzImage -initrd path/to/rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init nokaslr noapic" -nographic -virtfs local,path=/tmp/shared,mount_tag=shared,security_model=passthrough,id=shared

# ゲストでマウント
# mkdir -p /mnt/shared
# mount -t 9p -o trans=virtio,version=9p2000.L,cache=loose shared /mnt/shared

# ただしホストのディレクトリとuid gidを合わせないと書き込みできない
# 回避する為には QEMUをrootで実行する
# もしくは以下ユーザを作成してuid gidを合わせる
XUID=1001
XGID=1001
UNAME=testuser
GNAME=testuser

# (busyboxの場合)
touch /etc/group
touch /etc/passwd
addgroup -g ${XGID} ${GNAME}
mkdir -p /home/W${UNAME}
adduser -D -u ${XUID} -G ${GNAME} -s /bin/sh ${UNAME}
chown -R ${UNAME}:${GNAME} /home/${UNAME}
su - ${UNAME}

# (ディストリビューションの場合)
groupadd -g ${XGID} ${GNAME}
useradd -m -s /bin/bash -u ${XUID} -g ${XGID} -G sudo ${UNAME}
echo ${UNAME}:${GNAME} | chpasswd
su - ${UNAME}


################################
# initrdからブートして diskを追加

# 事前に ext4 イメージ作成
dd if=/dev/zero of=disk.img bs=1M count=10  # 10Mbytes
mkfs.ext4 disk.img

# -hda disk.img  追加のストレージとしてイメージを第1ドライブ（/dev/sda）として接続
# 詳細に設定するなら -drive で
qemu-system-x86_64 -kernel path/to/bzImage -initrd path/to/rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init nokaslr" -nographic -hda path/to/disk.img

# ゲストでマウント
mkdir -p /mnt/disk
mount -t ext4 /dev/sda /mnt/disk


################################
# qemuデフォルトネットワークについて
# https://wiki.qemu.org/Documentation/Networking
# https://www.qemu.org/docs/master/system/devices/net.html

# デフォルトではゲートウェイからDHCPでアドレスが割り当てられる
# (ゲストでDHCPサーバーやネットワーク設定がされている場合)
# ip      10.0.2.15
# subnet  255.255.255.0
# gateway 10.0.2.2

# ゲストでDHCPしない場合の設定例
NIC="eth0"
ip addr add 10.0.2.200/24 dev ${NIC}
ip link set ${NIC} up
ip route add default via 10.0.2.2

# ゲストからping(ICMP)を出すには以下をホストでセットする (制限効いていると UDP port7で出ていく)
sudo sysctl -w net.ipv4.ping_group_range="0 2147483647"  # 全てのGIDを許可 (再起動で消える)


################################
# virtio net を追加

# 事前にゲストkernelのビルドでVIRTIOを有効にする
# CONFIG_VIRTIO=y
# CONFIG_VIRTIO_PCI=y
# CONFIG_VIRTIO_NET=y

#  -device virtio-net-pci,netdev=net0  ゲストから見える仮想デバイス
#  -netdev user,id=net0                qemuバックエンド (仮想デバイスからホストへ繋ぐ)
qemu-system-x86_64 -kernel path/to/bzImage -initrd path/to/rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init nokaslr" -nographic -netdev user,id=net0 -device virtio-net-pci,netdev=net0


################################
# debootstrap bionicの例 minbase
sudo debootstrap --variant=minbase --arch=amd64 --include=systemd,systemd-sysv,udev,kmod,init bionic /tmp/debootstrap_bionic http://archive.ubuntu.com/ubuntu/

# rootfs.img作成...

# メモリ多めにしないと initramfs unpack時にoomkillerが発動する
# -m 512M or -m 1G
qemu-system-x86_64 -kernel path/to/bzImage -initrd path/to/rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init nokaslr" -nographic -m 512M


################################
# 作成した rootfs.img(initramfs CPIO形式) をdiskとして接続する

# 事前に CPIO を ext4 イメージに変換
dd if=/dev/zero of=disk.img bs=1M count=1024  # 1Gbytes
mkfs.ext4 disk.img
mkdir ./disk
sudo mount -t ext4 disk.img ./disk
cd disk
# rootfs.img(CPIO) は1つ上のディレクトリに置いてある前提
zcat ../rootfs.img | sudo cpio -idmv
cd ..
sudo umount disk

# -disk
#   file=path/to/disk.img  イメージのパス
#   format=raw             非圧縮の生ディスクイメージ形式
# kernel command
#   root=/dev/sda
qemu-system-x86_64 -kernel path/to/bzImage -drive file=path/to/disk.img,format=raw -append "console=ttyS0 root=/dev/sda rw nokaslr" -nographic

## virtio-blk で接続する場合 ##
# 事前にゲストkernelを以下コンフィグを追加してビルド
CONFIG_VIRTIO_BLK=y

# -disk
#   file=path/to/disk.img  イメージのパス
#   format=raw             非圧縮の生ディスクイメージ形式
#   if=virtio              virtioで接続
# kerenl command
#   root=/dev/vda
qemu-system-x86_64 -kernel path/to/bzImage -drive file=path/to/disk.img,format=raw,if=virtio -append "console=ttyS0 root=/dev/vda rw nokaslr" -nographic
